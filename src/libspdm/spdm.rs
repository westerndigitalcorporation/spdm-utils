// Licensed under the Apache License, Version 2.0 or the MIT License.
// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright (C) 2022, Western Digital Corporation or its affiliates.

//! Exposes the public functions of [libspdm](https://github.com/DMTF/libspdm)
//! to Rust.
//!
//! This file provides some helper functions for calling libspdm.
//!

// TODO: This should probably be cleaned up and autogenerated with
// [bindgen](https://rust-lang.github.io/rust-bindgen).

use crate::libspdm_rs;
// TODO: Remove this
use crate::libspdm_rs::*;
use core::slice::{from_raw_parts, from_raw_parts_mut};
use core::{ffi::c_void, fmt, ptr};

/// # Summary
///
/// At compile time, check that the type specified matches the type of the
/// function (of @name) generated by bindgen.
///
/// # Parameter
///
/// * `$t:ty`: The Fn type to test, use the local Fn type here.
/// * `$name:ident`: Name of Fn to test (must exist in generated bindings)
#[cfg(test)]
macro_rules! libspdm_match_fn_prototypes {
    ($t:ty, $name:ident) => {
        //check that the identifier $name has the type $t.
        const _: $t = $name;
        //checks that the identifier $name in generated bindings has the type $t.
        const _: $t = libspdm_rs::$name;
    };
}

#[cfg(feature = "no_std")]
use {
    alloc::alloc::{alloc, dealloc},
    alloc::ffi::CString,
    alloc::string::String,
    alloc::vec::Vec,
    core::alloc::Layout,
    core::ffi::{c_uchar, c_uint},
};

#[cfg(not(feature = "no_std"))]
use {
    crate::manifest,
    clap::ValueEnum,
    colored::Colorize,
    minicbor::CborLen,
    once_cell::sync::Lazy,
    std::alloc::{alloc, dealloc, Layout},
    std::ffi::{c_uchar, c_uint, CString},
    std::fs::OpenOptions,
    std::io::{BufRead, BufReader, BufWriter, Write},
    std::path::Path,
    std::sync::RwLock,
};

#[cfg(not(feature = "no_std"))]
/// The measurement values dynamically generated.
pub struct DynamicImageMeasurements {
    /// This is a list of hashes of the kernel
    /// This is set by the generate_kernel_hash() function which is run async
    /// at start up and then accessed via the
    /// libspdm_fill_measurement_image_hash_block() function
    pub kernel_hashes: [[u8; 64]; 3],
    /// Have the kernel hashes been populated
    pub kernel_hashes_populated: bool,
    /// This is a list of hashes of the running application
    /// This is set by the generate_app_hash() function which is run async
    /// at start up and then accessed via the
    /// libspdm_fill_measurement_image_hash_block() function
    pub app_hashes: [[u8; 64]; 3],
    /// Have the app hashes been populated
    pub app_hashes_populated: bool,
}

#[cfg(not(feature = "no_std"))]
impl Default for DynamicImageMeasurements {
    fn default() -> Self {
        DynamicImageMeasurements {
            kernel_hashes: [[0; 64]; 3],
            kernel_hashes_populated: false,
            app_hashes: [[0; 64]; 3],
            app_hashes_populated: false,
        }
    }
}

#[cfg(not(feature = "no_std"))]
pub static DYN_IMAGE_MEASURE: RwLock<Lazy<DynamicImageMeasurements>> =
    RwLock::new(Lazy::new(|| DynamicImageMeasurements::default()));

pub struct LibspdmReturnStatus;
pub struct SpdmVersionNumber(pub u16);
pub struct SpdmAlgoBaseAsym(pub u32);
pub struct SpdmAlgoBaseHash(pub u32);
pub struct SpdmAlgoDheNamedGroup(pub u32);
pub struct SpdmAlgoAeadCipherSuite(pub u32);
pub struct SpdmAlgoKeyScheduleHmacHash(pub u32);

impl fmt::Display for SpdmVersionNumber {
    /// Print the SPDM version in a human readable format
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(
            f,
            "SpdmVersion: {}.{}.{}.{}",
            (self.0 & 0xF000) >> 12,
            (self.0 & 0x0F00) >> 8,
            (self.0 & 0x00F0) >> 4,
            self.0 & 0x00F
        )
    }
}

impl fmt::Display for SpdmAlgoBaseAsym {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "Negotiated Asym Algos =>")?;
        if self.0 == 0 {
            return writeln!(f, "None");
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256 != 0 {
            writeln!(
                f,
                "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256"
            )?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384 != 0 {
            writeln!(
                f,
                "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384"
            )?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521 != 0 {
            writeln!(
                f,
                "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521"
            )?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448")?
        }
        Ok(())
    }
}

impl fmt::Display for SpdmAlgoBaseHash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "Negotiated Hash Algos =>")?;
        if self.0 == 0 {
            return writeln!(f, "None");
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_256")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_384")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_512 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA_512")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_256 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_256")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_384 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_384")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_512 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SHA3_512")?
        }
        if self.0 & SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SM3_256 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_BASE_HASH_ALGO_TPM_ALG_SM3_256")?
        }
        Ok(())
    }
}

impl fmt::Display for SpdmAlgoDheNamedGroup {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "Negotiated DHE Named group =>")?;
        if self.0 == 0 {
            return writeln!(f, "None");
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_2048")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_3072")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_4096 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_FFDHE_4096")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_256_R1")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_384_R1")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_521_R1 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_SECP_521_R1")?
        }
        if self.0 & SPDM_ALGORITHMS_DHE_NAMED_GROUP_SM2_P256 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_DHE_NAMED_GROUP_SM2_P256")?
        }
        Ok(())
    }
}

impl fmt::Display for SpdmAlgoAeadCipherSuite {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "Negotiated AEAD Cipher Suite =>")?;
        if self.0 == 0 {
            return writeln!(f, "None");
        }
        if self.0 & SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_128_GCM != 0 {
            writeln!(f, "SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_128_GCM")?
        }
        if self.0 & SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM != 0 {
            writeln!(f, "SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AES_256_GCM")?
        }
        if self.0 & SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305 != 0 {
            writeln!(f, "SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_CHACHA20_POLY1305")?
        }
        if self.0 & SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AEAD_SM4_GCM != 0 {
            writeln!(f, "SPDM_ALGORITHMS_AEAD_CIPHER_SUITE_AEAD_SM4_GCM")?
        }
        Ok(())
    }
}

impl fmt::Display for SpdmAlgoKeyScheduleHmacHash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "Negotiated Key Schedule HMAC Hash =>")?;
        if self.0 == 0 {
            return writeln!(f, "None");
        }
        if self.0 & SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH != 0 {
            writeln!(f, "SPDM_ALGORITHMS_KEY_SCHEDULE_HMAC_HASH")?
        }
        Ok(())
    }
}

#[cfg(not(feature = "no_std"))]
#[derive(ValueEnum, Debug, Clone, PartialEq, Copy)]
pub enum TransportLayer {
    /// PCIe Data Object Exchange
    Doe,
    /// DMTF Management Component Transport Protocol
    Mctp,
}

#[cfg(feature = "no_std")]
#[derive(Debug, Clone, PartialEq, Copy)]
pub enum TransportLayer {
    /// PCIe Data Object Exchange
    Doe,
    /// DMTF Management Component Transport Protocol
    Mctp,
}

/// Contains the information used to setup the current
/// SPDM session.
#[derive(Default)]
pub struct SpdmSessionInfo {
    // False means to use KEY_EXCHANGE/FINISH to start a session.
    // True means to use PSK_EXCHANGE/PSK_FINISH to start a session.
    pub use_psk: bool,
    // The type of the measurement hash.
    pub measurement_hash_type: u8,
    //  The number of slot for the certificate chain.
    pub slot_id: u8,
    // The policy for the session.
    pub session_policy: u8,
    // The session ID of the session.
    pub session_id: u32,
    // The heartbeat period for the session.
    pub heartbeat_period: u8,
}

impl fmt::Display for SpdmSessionInfo {
    /// A debug print format for the SpdmSessionInfo struct
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "\nCreated an SPDMSession with the following config:")?;

        let psk = match self.use_psk {
            true => String::from("PSK_EXCHANGE/PSK_FINISH to start a session"),
            _ => String::from("KEY_EXCHANGE/FINISH to start a session"),
        };
        writeln!(
            f,
            "use_psk: {}, measurement_hash_type: {}, slot_id: {},
        session_policy: {}, session_id: {}, heartbeat_period: {}",
            psk,
            self.measurement_hash_type,
            self.slot_id,
            self.session_policy,
            self.session_id,
            self.heartbeat_period
        )
    }
}

/* Maximum size of a large SPDM message.
 * If chunk is unsupported, it must be same as DATA_TRANSFER_SIZE.
 * If chunk is supported, it must be larger than DATA_TRANSFER_SIZE.
 * It matches MaxSPDMmsgSize in SPDM specification. */
pub const LIBSPDM_MAX_SPDM_MSG_SIZE: u32 = 0x2000;

const OPAQUE_SIZE: usize = 0;

const LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER: u32 = 2;
const LIBSPDM_MEASUREMENT_BLOCK_NUMBER: u8 =
    LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER as u8 + 1 + 1 + 1;

const LIBSPDM_MEASUREMENT_RAW_DATA_SIZE: u32 = 72;
#[allow(unused)]
const LIBSPDM_MEASUREMENT_MANIFEST_SIZE: u32 = (5 * 1024) - 1;
const LIBSPDM_MEASUREMENT_INDEX_SVN: u32 = 0x10;

// Key libspdm return status
pub const _LIBSPDM_STATUS_SUCCESS: u32 = 0x0;
pub const LIBSPDM_STATUS_UNSUPPORTED_CAP: u32 = 0x2;
pub const LIBSPDM_STATUS_INVALID_MSG_FIELD: u32 = 0x5;
pub const LIBSPDM_STATUS_INVALID_MSG_SIZE: u32 = 0x6;

// The index at which the raw bit-stream starts at within the
// measurement manifest buffer returned by libspdm.
pub const LIBSPDM_MANIFEST_RAW_BITSTREAM_OFFSET: usize = 0x07;

// This has to be valid during the life of the program due to the way
// libspdm_set_data() utilizes this by pointer.
const PSK_HINT: [u8; PSK_LEN] = [0xff; PSK_LEN];
const PSK_LEN: usize = 11;

/// Returns the severity of the status.
#[macro_export]
macro_rules! libspdm_status_severity {
    ($input:ident) => {
        ($input >> 28) & 0xf
    };
}

/// Returns the code of the status.
#[macro_export]
macro_rules! libspdm_status_code {
    ($input:ident) => {
        $input & 0xffff
    };
}

/// Returns the source of the status.
#[macro_export]
macro_rules! libspdm_status_source {
    ($input:ident) => {
        ($input & 0xfff0000) >> 16
    };
}

/// Generate the libspdm error
#[macro_export]
macro_rules! libspdm_status_construct {
    ($severity:ident, $source:ident, $code:expr) => {
        ($severity << 28) | ($source << 16) | ($code)
    };
}

impl LibspdmReturnStatus {
    /// Returns true if severity is LIBSPDM_SEVERITY_SUCCESS else it returns false.
    pub fn libspdm_status_is_success(status: u32) -> bool {
        let severity = libspdm_status_severity!(status);

        if severity == LIBSPDM_SEVERITY_SUCCESS {
            return true;
        }
        false
    }

    /// Returns true if severity is LIBSPDM_SEVERITY_ERROR else it returns false.
    pub fn libspdm_status_is_error(status: u32) -> bool {
        let severity = libspdm_status_severity!(status);

        if severity == LIBSPDM_SEVERITY_ERROR {
            return true;
        }
        false
    }
}

impl libspdm_rs::libspdm_data_parameter_t {
    pub fn new_local(slot_id: u8) -> Self {
        Self {
            location: 0, // LIBSPDM_DATA_LOCATION_LOCAL
            additional_data: [slot_id, 0, 0, 0],
        }
    }

    pub fn new_connection(slot_id: u8) -> Self {
        Self {
            location: 1, // LIBSPDM_DATA_LOCATION_CONNECTION
            additional_data: [slot_id, 0, 0, 0],
        }
    }
}

/// # Summary
///
/// 1.1: Allocate buffer for the spdm_context, initialize it, and setup
/// scratch_buffer.
///
/// # Returns
///
/// `cntx_ptr` pointing to the initialised SPDM context.
///
/// # Panics
///
/// Panics if failed to allocate for the SPDM or the scratch buffer.
pub fn initialise_spdm_context() -> *mut c_void {
    unsafe {
        let libspdm_cntx_size = libspdm_get_context_size();
        let libspdm_cntx_layout = Layout::from_size_align(libspdm_cntx_size, 8).unwrap();
        let libspdm_cntx = alloc(libspdm_cntx_layout);

        if libspdm_cntx.is_null() {
            panic!("Unable to allocate libspdm context");
        }

        let cntx_ptr: *mut c_void = libspdm_cntx as *mut _ as *mut c_void;

        libspdm_init_context(cntx_ptr);

        cntx_ptr
    }
}

/// # Summary
///
/// 1.3: Set capabilities and choose algorithms, based upon need
///
/// # Parameter
///
/// * `context`: The SPDM context
///
/// # Returns
///
/// Ok(()) on success
pub unsafe fn setup_transport_layer(
    context: *mut c_void,
    trans: TransportLayer,
    libspdm_max_spdm_msg_size: u32,
) -> Result<(), ()> {
    match trans {
        TransportLayer::Doe => {
            libspdm_register_transport_layer_func(
                context,
                libspdm_max_spdm_msg_size
                    - (LIBSPDM_PCI_DOE_TRANSPORT_HEADER_SIZE + LIBSPDM_PCI_DOE_TRANSPORT_TAIL_SIZE),
                LIBSPDM_PCI_DOE_TRANSPORT_HEADER_SIZE,
                LIBSPDM_PCI_DOE_TRANSPORT_TAIL_SIZE,
                Some(libspdm_transport_pci_doe_encode_message),
                Some(libspdm_transport_pci_doe_decode_message),
            );
        }
        TransportLayer::Mctp => {
            libspdm_register_transport_layer_func(
                context,
                libspdm_max_spdm_msg_size
                    - (LIBSPDM_MCTP_TRANSPORT_HEADER_SIZE + LIBSPDM_MCTP_TRANSPORT_TAIL_SIZE),
                LIBSPDM_MCTP_TRANSPORT_HEADER_SIZE,
                LIBSPDM_MCTP_TRANSPORT_TAIL_SIZE,
                Some(libspdm_transport_mctp_encode_message),
                Some(libspdm_transport_mctp_decode_message),
            );
        }
    }

    let libspdm_scratch_buffer_size = libspdm_get_sizeof_required_scratch_buffer(context);
    let libspdm_scratch_buffer_layout =
        match Layout::from_size_align(libspdm_scratch_buffer_size, 8) {
            Ok(layout) => layout,
            Err(e) => {
                error!("Failed to generate layout: {:?}", e);
                return Err(());
            }
        };
    let libspdm_scratch_buffer = alloc(libspdm_scratch_buffer_layout);

    if libspdm_scratch_buffer.is_null() {
        error!("Unable to allocate libspdm scratch buffer");
        return Err(());
    }

    let libspdm_scratch_buffer_ptr: *mut c_void = libspdm_scratch_buffer as *mut _ as *mut c_void;

    libspdm_set_scratch_buffer(
        context,
        libspdm_scratch_buffer_ptr,
        libspdm_scratch_buffer_size,
    );

    Ok(())
}

/// # Summary
///
/// 2: Create connection with the responder
///
/// # Parameter
///
/// * `context`: The SPDM context
/// * `slot_id`: Session slot-id
///
/// # Returns
///
/// Ok(()) on success
/// Err(ret), where ret is a libspdm return status indicating an error.
pub unsafe fn initialise_connection(context: *mut c_void, slot_id: u8) -> Result<(), u32> {
    let ret = libspdm_init_connection(context, false);

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        error!("libspdm_init_connection: failed with {:x?}", ret);
        return Err(ret);
    }

    let mut slot_mask: u8 = 0;
    let mut total_digest_buffer: [u8; (LIBSPDM_MAX_HASH_SIZE * SPDM_MAX_SLOT_COUNT) as usize] =
        [0; (LIBSPDM_MAX_HASH_SIZE * SPDM_MAX_SLOT_COUNT) as usize];
    let total_digest_buffer_ptr: *mut c_void = &mut total_digest_buffer as *mut _ as *mut c_void;

    let ret = libspdm_get_digest(
        context,
        ptr::null_mut(),
        &mut slot_mask,
        total_digest_buffer_ptr,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        error!("libspdm_get_digest(): failed with {:x?}", ret);
        return Err(ret);
    }

    let mut cert_chain_size: usize = LIBSPDM_MAX_CERT_CHAIN_SIZE as usize;
    let mut cert_chain: [u8; LIBSPDM_MAX_CERT_CHAIN_SIZE as usize] =
        [0; LIBSPDM_MAX_CERT_CHAIN_SIZE as usize];
    let cert_chain_ptr: *mut c_void = &mut cert_chain as *mut _ as *mut c_void;

    let ret = libspdm_get_certificate(
        context,
        ptr::null_mut(),
        slot_id,
        &mut cert_chain_size,
        cert_chain_ptr,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        error!("libspdm_get_certificate(): failed with {:x?}", ret);
        return Err(ret);
    }

    let mut measurement_hash: [u8; LIBSPDM_MAX_HASH_SIZE as usize] =
        [0; LIBSPDM_MAX_HASH_SIZE as usize];
    let measurement_hash_ptr: *mut c_void = &mut measurement_hash as *mut _ as *mut c_void;

    let ret = libspdm_challenge(
        context,
        ptr::null_mut(),
        slot_id,
        SPDM_CHALLENGE_REQUEST_TCB_COMPONENT_MEASUREMENT_HASH as u8,
        measurement_hash_ptr,
        ptr::null_mut(),
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        error!("libspdm_challenge(): failed with {:x?}", ret);
        return Err(ret);
    }

    Ok(())
}

/// # Summary
///
/// Decodes, saves and logs a CBOR encoded @measurement_manifest.
///
/// # Parameter
///
/// * `measurement_manifest`: A buffer containing the CBOR encoded measurement
///    manifest
///
/// # Returns
///
/// Ok(()), on success
/// Err(), on failures to decode/save to file
#[cfg(not(feature = "no_std"))]
pub fn process_cbor_measurement_manifest(
    context: *mut c_void,
    slot_id: u8,
    measurement_manifest: &[u8],
) -> Result<(), ()> {
    print_measurement_manifest(measurement_manifest, false)?;

    let spdm_toc =
        manifest::generate_direct_manifest(context, slot_id, &measurement_manifest).unwrap();

    let mut direct_manifest = [0u8; 1024];
    let original_len = measurement_manifest.len();
    assert!(original_len < 1024);
    minicbor::Encoder::new(direct_manifest.as_mut())
        .encode(&spdm_toc)
        .unwrap();
    let length = spdm_toc.cbor_len(&mut ());

    print_measurement_manifest(&direct_manifest[0..length], true)?;

    Ok(())
}

#[cfg(not(feature = "no_std"))]
fn print_measurement_manifest(measurement_manifest: &[u8], direct: bool) -> Result<(), ()> {
    let prefix = if direct { "Direct " } else { "" };

    // Print the measurement manifest in raw-bitstream form(as received), as fail-safe
    // incase we failed to decode.
    debug!(
        "---{prefix}Measurement manifest {} start---",
        "raw-bitstream".red()
    );
    debug!("\n{:x?}", measurement_manifest);
    debug!(
        "---{prefix}Measurement manifest {} end---",
        "raw-bitstream".red()
    );

    // Save the manifest in CBOR diagnostic format
    match manifest::decode_cbor_manifest(&measurement_manifest, false) {
        Ok(decoded_bytes) => {
            let path = if direct {
                Path::new("manifest/responder_manifest.cbor")
            } else {
                Path::new("manifest/direct_responder_manifest.cbor")
            };
            manifest::save_manifest_to_file(&decoded_bytes, path).unwrap();
            info!(
                "---{prefix}Decoded measurement manifest {} received---",
                "diagnostic".blue()
            );
            info!(
                "\n{}",
                String::from_utf8_lossy(&decoded_bytes).blue().bold()
            );
            info!(
                "---{prefix}Decoded measurement manifest {} end---",
                "diagnostic".blue()
            );
        }
        Err(e) => {
            warn!("Failed to decode manifest into diagnostic format");
            return Err(e);
        }
    }

    // Save the manifest in pretty format
    match manifest::decode_cbor_manifest(&measurement_manifest, true) {
        Ok(decoded_bytes) => {
            let path = if direct {
                Path::new("manifest/responder_manifest.pretty")
            } else {
                Path::new("manifest/direct_responder_manifest.pretty")
            };
            manifest::save_manifest_to_file(&decoded_bytes, path).unwrap();

            info!(
                "---{prefix}Decoded measurement manifest {} received---",
                "pretty".green()
            );
            info!(
                "\n{}",
                String::from_utf8_lossy(&decoded_bytes).green().bold()
            );
            info!(
                "---{prefix}Decoded measurement manifest {} end---",
                "pretty".green()
            );
        }
        Err(e) => {
            warn!("Failed to decode manifest into pretty format");
            return Err(e);
        }
    }

    Ok(())
}

/// # Summary
///
/// 4: Get all of the measurements from the Responder
///
/// # Parameter
///
/// * `context`: The SPDM context
/// * `slot_id`: Session slot-id
///
/// # Returns
///
/// Ok(()) on success
/// Err(ret), where ret is a libspdm return status indicating an error.
#[cfg(not(feature = "no_std"))]
pub unsafe fn get_measurements(context: *mut c_void, slot_id: u8) -> Result<(), u32> {
    let mut request_attribute: u8 =
        libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE as u8;
    let mut num_measures: u8 = 0;

    // Get the total number of measurements
    let ret = libspdm_get_measurement(
        context,
        ptr::null_mut(),
        request_attribute,
        SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS as u8,
        slot_id,
        ptr::null_mut(),
        &mut num_measures,
        ptr::null_mut(),
        ptr::null_mut(),
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    // Probe the measurements one by one
    // This is a waste of time as we can just collect all of the measurements,
    // but it provides a useful test
    for measurement_index in 1..0xFF {
        let mut number_of_blocks: u8 = 0;
        let mut measurement_record_length: u32 = LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE;
        let mut measurement_record: [u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize] =
            [0; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize];
        let measurement_record_ptr: *mut c_void = &mut measurement_record as *mut _ as *mut c_void;

        if measurement_index == SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST {
            // Request the raw bitstream, so we can decode it for readability.
            request_attribute =
                libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_RAW_BIT_STREAM_REQUESTED as u8;
        } else {
            request_attribute =
                libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE as u8;
        }

        let ret = libspdm_get_measurement(
            context,
            ptr::null_mut(),
            request_attribute,
            measurement_index as u8,
            slot_id,
            ptr::null_mut(),
            &mut number_of_blocks,
            &mut measurement_record_length,
            measurement_record_ptr,
        );

        if LibspdmReturnStatus::libspdm_status_is_success(ret) {
            // If it was a success, reduce the number of measures
            // we are still looking for
            if num_measures == 0 {
                // We have found too many measurements
                return Err(libspdm_status_construct!(
                    LIBSPDM_SEVERITY_ERROR,
                    LIBSPDM_SOURCE_MEAS_COLLECT,
                    0x0001
                ));
            }

            num_measures -= 1;
        } else if ret
            == libspdm_status_construct!(LIBSPDM_SEVERITY_ERROR, LIBSPDM_SOURCE_CORE, 0x000a)
        {
            // Wrong index, just continue
        } else {
            return Err(ret);
        }

        // Measurement Manifest
        if measurement_index == SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST {
            // Let's attempt to decode this (assuming CBOR encoding),
            // a decoding failure likely implies that this was not CBOR encoded/serialised properly.

            let measurement_manifest = &measurement_record
                [LIBSPDM_MANIFEST_RAW_BITSTREAM_OFFSET..measurement_record_length as usize];
            if process_cbor_measurement_manifest(context, slot_id, measurement_manifest).is_err() {
                error!("Failed to process measurement manifest");
            }
        }
    }

    if num_measures != 0 {
        // We somehow didn't find all of the measurements
        return Err(libspdm_status_construct!(
            LIBSPDM_SEVERITY_ERROR,
            LIBSPDM_SOURCE_MEAS_COLLECT,
            0x0001
        ));
    }

    // Collect all of the measurements
    let mut number_of_blocks: u8 = 0;
    let mut measurement_record_length: u32 = LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE;
    let mut measurement_record: [u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize] =
        [0; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize];
    let measurement_record_ptr: *mut c_void = &mut measurement_record as *mut _ as *mut c_void;

    for i in 0..2 {
        if i == 0 {
            // Request the raw bitstream, so we can decode it for readability.
            request_attribute =
                libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_RAW_BIT_STREAM_REQUESTED as u8;
        } else {
            request_attribute =
                libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE as u8;
        }

        let ret = libspdm_get_measurement(
            context,
            ptr::null_mut(),
            request_attribute,
            SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_ALL_MEASUREMENTS as u8,
            slot_id,
            ptr::null_mut(),
            &mut number_of_blocks,
            &mut measurement_record_length,
            measurement_record_ptr,
        );

        if LibspdmReturnStatus::libspdm_status_is_error(ret) {
            return Err(ret);
        }
    }

    Ok(())
}

/// # Summary
///
/// Get the number of measurement blocks supported
///
/// # Parameter
///
/// * `context`: The SPDM context
/// * `slot_id`: Session slot-id
/// * `measurement_record`: A buffer to store the data in
///
/// # Returns
///
/// Ok(num_of_blocks) on success
/// Err(e), where e is a libspdm return status indicating an error.
pub unsafe fn get_num_meas_blocks(
    context: *mut c_void,
    slot_id: u8,
    measurement_record: &mut [u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize],
) -> Result<u8, u32> {
    let mut number_of_blocks: u8 = 0;
    let mut measurement_record_length: u32 = measurement_record.len() as u32;
    let measurement_record_ptr: *mut c_void = measurement_record as *mut _ as *mut c_void;

    let request_attribute =
        libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE as u8;

    let ret = libspdm_get_measurement(
        context,
        ptr::null_mut(),
        request_attribute,
        SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS as u8,
        slot_id,
        ptr::null_mut(),
        &mut number_of_blocks,
        &mut measurement_record_length,
        measurement_record_ptr,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    Ok(number_of_blocks)
}

/// # Summary
///
/// Get a single measurement from a responder
///
/// # Parameter
///
/// * `context`: The SPDM context
/// * `slot_id`: Session slot-id
/// * `measurement_index`: The measurement index we want to retrieve
/// * `measurement_record`: A buffer to store the data in
///
/// # Returns
///
/// Ok((dmtf_spec_measure_type, measurement_record_length)) on success
/// Err(ret), where ret is a libspdm return status indicating an error.
#[cfg(not(feature = "no_std"))]
pub unsafe fn get_measurement(
    context: *mut c_void,
    slot_id: u8,
    raw_bitstream: bool,
    measurement_index: u32,
    measurement_record: &mut [u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize],
) -> Result<(u8, u32), u32> {
    let mut number_of_blocks: u8 = 0;
    let mut measurement_record_length: u32 = measurement_record.len() as u32;
    let measurement_record_ptr: *mut c_void = measurement_record as *mut _ as *mut c_void;
    let mut decode_measurement_manifest = true;

    if measurement_index as u32 == SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST
        && !raw_bitstream
    {
        warn!("The measurement manifest will not be decoded unless fetched as raw-bitstream!");
        decode_measurement_manifest = false;
    }

    let request_attribute = if raw_bitstream {
        libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_RAW_BIT_STREAM_REQUESTED as u8
    } else {
        libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE as u8
    };

    let ret = libspdm_get_measurement(
        context,
        ptr::null_mut(),
        request_attribute,
        measurement_index as u8,
        slot_id,
        ptr::null_mut(),
        &mut number_of_blocks,
        &mut measurement_record_length,
        measurement_record_ptr,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    // Measurement Manifest
    if measurement_index == SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST
        && decode_measurement_manifest
    {
        // Let's attempt to decode this (assuming CBOR encoding),
        // a decoding failure likely implies that this was not CBOR encoded/serialised properly.

        let measurement_manifest = &measurement_record
            [LIBSPDM_MANIFEST_RAW_BITSTREAM_OFFSET..measurement_record_length as usize];
        if process_cbor_measurement_manifest(context, slot_id, measurement_manifest).is_err() {
            error!("Failed to process measurement manifest");
        }
    }

    let measurement_block =
        measurement_record_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;

    if (*measurement_block).measurement_block_common_header.index != measurement_index as u8 {
        return Err(0);
    }

    if (*measurement_block)
        .measurement_block_common_header
        .measurement_specification
        != libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8
    {
        return Err(0);
    }

    let dmtf_spec_measure_type = (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type;

    Ok((dmtf_spec_measure_type, measurement_record_length))
}

/// # Summary
///
/// 5: Manage/start an SPDM session.
///
/// # Parameter
///
/// * `context`: The SPDM context
/// * `slot_id`: Session slot-id
/// * `use_psk`: usk PSK_EXCHANGE/PSK_FINISH if true, else KEY_EXCHANGE/FINISH
///
/// # Returns
///
/// Ok(()) on success
/// Err(ret), where ret is a libspdm return status indicating an error.
pub unsafe fn start_session(
    context: *mut c_void,
    slot_id: u8,
    use_psk: bool,
) -> Result<SpdmSessionInfo, u32> {
    let mut session_info = SpdmSessionInfo {
        use_psk,
        measurement_hash_type: SPDM_CHALLENGE_REQUEST_TCB_COMPONENT_MEASUREMENT_HASH as u8,
        slot_id,
        session_policy: 0,
        session_id: 0,
        heartbeat_period: 0,
    };
    let mut measurement_hash: [u8; LIBSPDM_MAX_HASH_SIZE as usize] =
        [0; LIBSPDM_MAX_HASH_SIZE as usize];
    let measurement_hash_ptr: *mut c_void = &mut measurement_hash as *mut _ as *mut c_void;

    let ret = libspdm_start_session(
        context,
        session_info.use_psk, // KeyExchange
        &PSK_HINT as *const _ as *const c_void,
        PSK_LEN as u16,
        session_info.measurement_hash_type,
        session_info.slot_id,
        session_info.session_policy,
        &mut session_info.session_id,
        &mut session_info.heartbeat_period,
        measurement_hash_ptr,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        // Gracefully handle an unsupported capability error from a responder
        if libspdm_status_code!(ret) == LIBSPDM_STATUS_UNSUPPORTED_CAP {
            error!("Unsupported capability detected from responder");
        } else {
            return Err(ret);
        }
    }
    Ok(session_info)
}

#[no_mangle]
pub unsafe extern "C" fn libspdm_requester_data_sign(
    _spdm_context: *mut c_void,
    _spdm_version: libspdm_rs::spdm_version_number_t,
    _op_code: u8,
    _req_base_asym_alg: u16,
    _base_hash_algo: u32,
    _is_data_hash: bool,
    _message: *const u8,
    _message_size: usize,
    _signature: *mut u8,
    _sig_size: *mut usize,
) -> bool {
    todo!();
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        u16,
        u32,
        bool,
        *const u8,
        usize,
        *mut u8,
        *mut usize,
    ) -> bool,
    libspdm_requester_data_sign
);

/// # Summary
///
/// Sign an SPDM message data
///
/// # Parameter
///
/// * `spdm_version`: The SPDM version
/// * `op_code`: Operation code
/// * `base_asym_algo`: Indicates the signing algorithm
/// * `base_hash_algo`: Indicates the hash algorithm
/// * `is_data_hash`: Indicate the message type. true: raw message before hash,
///                   false: message hash
///
/// * `message`: A pointer to a message to be signed
/// * `message_size`: The size in bytes of the message to be signed
/// * `signature`: A pointer to a destination buffer to store the signature
/// * `sig_size`: On input, indicates the size in bytes of the destination
///                 buffer to store the signature
///               On output, indicates the size in bytes of the signature in
///                 the buffer
///
/// # Returns
///
/// True  signing success, false otherwise
#[no_mangle]
pub unsafe extern "C" fn libspdm_responder_data_sign(
    _spdm_context: *mut c_void,
    spdm_version: libspdm_rs::spdm_version_number_t,
    op_code: u8,
    base_asym_algo: u32,
    base_hash_algo: u32,
    is_data_hash: bool,
    message: *const u8,
    message_size: usize,
    signature: *mut u8,
    sig_size: *mut usize,
) -> bool {
    let mut context: *mut c_void = ptr::null_mut();
    let buffer;

    #[cfg(feature = "no_std")]
    {
        buffer = include_bytes!("../../certs/slot0/end_responder.key");
    }
    #[cfg(not(feature = "no_std"))]
    let mut reader;
    #[cfg(not(feature = "no_std"))]
    {
        let path = Path::new("certs/slot0/end_responder.key");

        let file = match OpenOptions::new().read(true).write(false).open(path) {
            Err(why) => panic!("couldn't open {}: {}", path.display(), why),
            Ok(file) => file,
        };

        reader = BufReader::new(file);
        buffer = reader.fill_buf().unwrap();
    }

    let buffer_len = buffer.len();

    let key_buffer_layout = Layout::from_size_align(buffer_len, 8).unwrap();
    let key_buffer = alloc(key_buffer_layout);

    key_buffer.copy_from(buffer.as_ptr(), buffer_len);

    let result = libspdm_asym_get_private_key_from_pem(
        base_asym_algo,
        key_buffer,
        buffer_len,
        ptr::null_mut(),
        &mut context,
    );
    if !result {
        key_buffer.write_bytes(0, buffer_len);
        dealloc(key_buffer, key_buffer_layout);
        return false;
    }

    let result = if is_data_hash {
        libspdm_asym_sign_hash(
            spdm_version,
            op_code,
            base_asym_algo,
            base_hash_algo,
            context,
            message,
            message_size,
            signature,
            sig_size,
        )
    } else {
        libspdm_asym_sign(
            spdm_version,
            op_code,
            base_asym_algo,
            base_hash_algo,
            context,
            message,
            message_size,
            signature,
            sig_size,
        )
    };
    libspdm_asym_free(base_asym_algo, context);
    key_buffer.write_bytes(0, buffer_len);
    dealloc(key_buffer, key_buffer_layout);

    result
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        u32,
        u32,
        bool,
        *const u8,
        usize,
        *mut u8,
        *mut usize,
    ) -> bool,
    libspdm_responder_data_sign
);

/// # Summary
///
/// Saves a certificate pointed to by `cert_chain` to device non-volatile memory
/// into the respective `slot_id`. Once saved, import the file and use it as
///  the certificate
///
/// # Parameter
///
/// * `slot_id`: The number of slot for the certificate chain
/// * `cert_chain`: The pointer for the certificate chain to set
/// * `cert_chain_size`: The size of the certificate chain to set
/// * `base_hash_algo`: Indicates the negotiated hash algorithm.
/// * `base_asym_algo`: Indicates the negotiated signing algorithms.
///
/// # Returns
///
/// True if certificate saved to NV successfully, otherwise, false
#[allow(unused)]
#[no_mangle]
pub unsafe extern "C" fn libspdm_write_certificate_to_nvm(
    _spdm_context: *mut c_void,
    slot_id: u8,
    cert_chain: *const c_void,
    cert_chain_size: usize,
    _base_hash_algo: u32,
    _base_asym_algo: u32,
) -> bool {
    #[cfg(feature = "no_std")]
    {
        todo!("implement: non-volatile storage");
    }
    #[cfg(not(feature = "no_std"))]
    {
        // TODO: We have no way to know if this is an alias or device
        // certificate.
        let dir_name = format!("certs/alias/slot{}", slot_id);
        let file_name = format!("{}/immutable.der", dir_name);
        let path = Path::new(&file_name);

        std::fs::create_dir_all(dir_name).unwrap();

        let file = match OpenOptions::new()
            .read(true)
            .write(true)
            .create(true)
            .open(path)
        {
            Err(why) => panic!("couldn't open {}: {}", path.display(), why),
            Ok(file) => file,
        };

        let mut writer = BufWriter::new(file);
        let slice = from_raw_parts(cert_chain as *const u8, cert_chain_size);

        writer.write_all(slice).unwrap();

        true
    }
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(*mut c_void, u8, *const c_void, usize, u32, u32) -> bool,
    libspdm_write_certificate_to_nvm
);

/// # Summary
///
/// Saves a certificate pointed to by `cert_chain` to device non-volatile memory
/// into the respective `slot_id`. Once saved, import the file and use it as
///  the certificate
///
/// # Parameter
///
/// * `base_hash_algo`: Indicates the hash algo for signing
/// * `base_asym_algo`: The asymmetric public key to set
/// * `need_reset`: The device needs reset to generate a CSR
/// * `requester_info`: Requester information to generate a CSR
/// * `requester_info_length`: The length of `requester_info`
/// * `csr_len`: For input, csr_len is the size of store CSR buffer.
///              For output, csr_len is CSR len for DER format
///
/// * `csr_pointer`: For input, csr_pointer is buffer address to store CSR.
///                  For output, csr_pointer is address for stored CSR.
///                  The csr_pointer address will be changed.
///
/// # Returns
///
/// True if CSR generation was a success, false otherwise
#[no_mangle]
pub unsafe extern "C" fn libspdm_gen_csr(
    _spdm_context: *mut c_void,
    base_hash_algo: u32,
    base_asym_algo: u32,
    need_reset: *mut bool,
    _request: *const c_void,
    _request_size: usize,
    requester_info: *mut u8,
    requester_info_length: usize,
    _opaque_data: *mut u8,
    _opaque_data_length: u16,
    csr_len: *mut usize,
    csr_pointer: *mut u8,
    is_device_cert_model: bool,
) -> bool {
    let mut ec_context: *mut c_void = ptr::null_mut();
    let csr_buffer_size: usize = *csr_len;
    let key_buffer;

    *need_reset = false;

    #[cfg(feature = "no_std")]
    {
        if is_device_cert_model {
            panic!("DeviceCert Model is unsupported");
        } else {
            key_buffer = include_bytes!("../../certs/alias/slot0/device.key");
        }
    }
    #[cfg(not(feature = "no_std"))]
    let mut key_reader;
    #[cfg(not(feature = "no_std"))]
    {
        let key_path = if is_device_cert_model {
            Path::new("certs/device/slot0/device.key")
        } else {
            Path::new("certs/alias/slot0/device.key")
        };

        let key_file = match OpenOptions::new().read(true).write(false).open(key_path) {
            Err(why) => panic!("couldn't open {}: {}", key_path.display(), why),
            Ok(file) => file,
        };

        key_reader = BufReader::new(key_file);
        key_buffer = key_reader.fill_buf().unwrap();
    }

    let key_buffer_len = key_buffer.len();

    let key_buffer_layout = Layout::from_size_align(key_buffer_len, 8).unwrap();
    let alloc_key_buffer = alloc(key_buffer_layout);

    alloc_key_buffer.copy_from(key_buffer.as_ptr(), key_buffer_len);

    let result = libspdm_asym_get_private_key_from_pem(
        base_asym_algo,
        alloc_key_buffer,
        key_buffer_len,
        ptr::null_mut(),
        &mut ec_context,
    );
    if !result {
        alloc_key_buffer.write_bytes(0, key_buffer_len);
        dealloc(alloc_key_buffer, key_buffer_layout);
        return false;
    }

    let cert_buffer;

    #[cfg(feature = "no_std")]
    {
        if is_device_cert_model {
            panic!("DeviceCert Model is unsupported");
        } else {
            cert_buffer = include_bytes!("../../certs/alias/slot0/device.cert.der");
        }
    }
    #[cfg(not(feature = "no_std"))]
    let mut cert_reader;
    #[cfg(not(feature = "no_std"))]
    {
        let cert_path = if is_device_cert_model {
            Path::new("certs/device/slot0/device.cert.der")
        } else {
            Path::new("certs/alias/slot0/device.cert.der")
        };

        let cert_file = match OpenOptions::new().read(true).write(false).open(cert_path) {
            Err(why) => panic!("couldn't open {}: {}", cert_path.display(), why),
            Ok(file) => file,
        };

        cert_reader = BufReader::new(cert_file);
        cert_buffer = cert_reader.fill_buf().unwrap();
    }

    let cert_buffer_len = cert_buffer.len();

    let cert_buffer_layout = Layout::from_size_align(cert_buffer_len, 8).unwrap();
    let mut alloc_cert_buffer = alloc(cert_buffer_layout);

    libspdm_x509_construct_certificate(
        cert_buffer.as_ptr(),
        cert_buffer_len,
        &mut alloc_cert_buffer,
    );

    let hash_nid = libspdm_get_hash_nid(base_hash_algo);
    let asym_nid = libspdm_get_aysm_nid(base_asym_algo);

    let subject_name =
        CString::new("C=AU,O=Western Digital Test,CN=Western Digital AN300 Test CSR").unwrap();

    let result = libspdm_gen_x509_csr(
        hash_nid,
        asym_nid,
        requester_info,
        requester_info_length,
        !is_device_cert_model,
        ec_context,
        subject_name.into_raw(),
        csr_len,
        csr_pointer,
        alloc_cert_buffer as *mut c_void,
    );

    libspdm_asym_free(base_asym_algo, ec_context);
    alloc_key_buffer.write_bytes(0, key_buffer_len);
    dealloc(alloc_key_buffer, key_buffer_layout);

    if csr_buffer_size < *csr_len {
        return false;
    }

    result
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        u32,
        u32,
        *mut bool,
        *const c_void,
        usize,
        *mut u8,
        usize,
        *mut u8,
        u16,
        *mut usize,
        *mut u8,
        bool,
    ) -> bool,
    libspdm_gen_csr
);

/// # Summary
///
/// Calculates the measurement summary hash.
///
/// # Parameter
///
/// * `spdm_version`: The SPDM version.
/// * `base_hash_algo`: The hash algorithm to use on summary
/// * `measurement_specification`: Indicates the measurement specification
///                              It must align with measurement_specification
///                              (SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_*)
///
/// * `measurement_hash_algo`: Indicates the measurement hash algorithm
///                             It must align with measurement_hash_alg
///                             (SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_*)
///
/// * `measurement_summary_hash_type`: The type of the measurement summary hash.
/// * `measurement_summary_hash`: The buffer to store the measurement summary hash.
/// * `measurement_summary_hash_size`: The size in bytes of the buffer.
///
/// # Returns
///
/// True if measurement summary hash is generated or skipped
/// False if the measurement summary has is not generated/generation failure
#[no_mangle]
pub unsafe extern "C" fn libspdm_generate_measurement_summary_hash(
    spdm_context: *mut c_void,
    spdm_version: libspdm_rs::spdm_version_number_t,
    base_hash_algo: u32,
    measurement_specification: u8,
    measurement_hash_algo: u32,
    measurement_summary_hash_type: u8,
    measurement_summary_hash: *mut u8,
    measurement_summary_hash_size: u32,
) -> bool {
    match measurement_summary_hash_type as u32 {
        SPDM_CHALLENGE_REQUEST_NO_MEASUREMENT_SUMMARY_HASH => true,
        SPDM_CHALLENGE_REQUEST_TCB_COMPONENT_MEASUREMENT_HASH
        | SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH => {
            if measurement_summary_hash_size != (libspdm_rs::libspdm_get_hash_size(base_hash_algo))
            {
                return false;
            }

            /* get all measurement data*/
            let mut device_measurement = [0u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize];
            let mut device_measurement_ptr: *mut c_void =
                &mut device_measurement as *mut _ as *mut c_void;
            let mut device_measurement_size = LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize;
            let mut device_measurement_count = 0;

            let ret = libspdm_measurement_collection(
                spdm_context,
                spdm_version,
                measurement_specification,
                measurement_hash_algo,
                0xFF, /* Get all measurements*/
                0,
                ptr::null_mut(),
                &mut device_measurement_count,
                device_measurement_ptr,
                &mut device_measurement_size,
            );
            if LibspdmReturnStatus::libspdm_status_is_error(ret) {
                return false;
            }

            /* get required data and hash them*/
            let mut measurement_data = [0u8; LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE as usize];
            let mut measurement_data_size = 0;

            let mut device_measurement_offset = 0;

            for _i in 0..device_measurement_count {
                let cached_measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t =
                    core::mem::transmute(device_measurement_ptr);

                let measurement_block_size = core::mem::size_of::<
                    spdm_measurement_block_common_header_t,
                >() + (*cached_measurement_block)
                    .measurement_block_common_header
                    .measurement_size as usize;
                /* filter unneeded data*/
                if (measurement_summary_hash_type
                    == SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH as u8)
                    || ((*cached_measurement_block)
                        .measurement_block_dmtf_header
                        .dmtf_spec_measurement_value_type
                        & SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_MASK as u8)
                        == (SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_IMMUTABLE_ROM as u8)
                {
                    if u32::from(spdm_version)
                        < (libspdm_rs::SPDM_MESSAGE_VERSION_12
                            << libspdm_rs::SPDM_VERSION_NUMBER_SHIFT_BIT)
                    {
                        let length = (*cached_measurement_block)
                            .measurement_block_common_header
                            .measurement_size as usize;
                        let measurement_block_dmtf_header_size =
                            core::mem::size_of::<spdm_measurement_block_common_header_t>();
                        let base_offset =
                            device_measurement_offset + measurement_block_dmtf_header_size;

                        measurement_data[measurement_data_size..(measurement_data_size + length)]
                            .copy_from_slice(
                                &device_measurement[base_offset..(base_offset + length)],
                            );

                        measurement_data_size += (*cached_measurement_block)
                            .measurement_block_common_header
                            .measurement_size
                            as usize;
                    } else {
                        measurement_data[measurement_data_size
                            ..(measurement_data_size + measurement_block_size)]
                            .copy_from_slice(
                                &device_measurement[device_measurement_offset
                                    ..(device_measurement_offset + measurement_block_size)],
                            );

                        measurement_data_size += measurement_block_size;
                    }
                }
                device_measurement_ptr =
                    device_measurement_ptr.wrapping_add(measurement_block_size);
                device_measurement_offset += measurement_block_size;
            }

            let measurement_data_ptr: *mut c_void = &mut measurement_data as *mut _ as *mut c_void;

            let result = libspdm_rs::libspdm_hash_all(
                base_hash_algo,
                measurement_data_ptr,
                measurement_data_size,
                measurement_summary_hash,
            );
            if !result {
                return false;
            }

            true
        }
        _ => false,
    }
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u32,
        u8,
        u32,
        u8,
        *mut u8,
        u32,
    ) -> bool,
    libspdm_generate_measurement_summary_hash
);

/// # Summary
///
/// Fill the image hash measurement block. This will use either the dynamic
/// or the static function, depending on what has previously been setup.
///
/// # Parameter
///
/// * `use_bit_stream`: Use raw bit-stream, no hash algorithm specified
/// * `measurement_hash_algo`: Indicates the measurement hash algorithm
/// * `measurements_index`: Index of the measurement
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
fn libspdm_fill_measurement_image_hash_block(
    use_bit_stream: bool,
    measurement_hash_algo: u32,
    measurements_index: u8,
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
) -> usize {
    #[cfg(not(feature = "no_std"))]
    {
        let dyn_image_measure = &DYN_IMAGE_MEASURE.read().unwrap();

        // Check if the values for dyn_image_measure have been initalised.
        // If they have let's use them, otherwise they won't be created
        if Lazy::get(dyn_image_measure).is_some() {
            unsafe {
                fill_dynamic_measurement_image_hash_block(
                    use_bit_stream,
                    measurement_hash_algo,
                    measurements_index,
                    measurement_block,
                )
            }
        } else {
            unsafe {
                fill_static_measurement_image_hash_block(
                    use_bit_stream,
                    measurement_hash_algo,
                    measurements_index,
                    measurement_block,
                )
            }
        }
    }

    #[cfg(feature = "no_std")]
    unsafe {
        fill_static_measurement_image_hash_block(
            use_bit_stream,
            measurement_hash_algo,
            measurements_index,
            measurement_block,
        )
    }
}

/// # Summary
///
/// Fill the image hash measurement block.
///
/// # Parameter
///
/// * `use_bit_stream`: Use raw bit-stream, no hash algorithm specified
/// * `measurement_hash_algo`: Indicates the measurement hash algorithm
/// * `measurements_index`: Index of the measurement
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
unsafe fn fill_static_measurement_image_hash_block(
    use_bit_stream: bool,
    measurement_hash_algo: u32,
    measurements_index: u8,
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
) -> usize {
    let data = [measurements_index; LIBSPDM_MEASUREMENT_RAW_DATA_SIZE as usize];
    let hash_size = libspdm_rs::libspdm_get_measurement_hash_size(measurement_hash_algo) as usize;

    (*measurement_block).measurement_block_common_header.index = measurements_index;
    (*measurement_block)
        .measurement_block_common_header
        .measurement_specification = libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8;

    if !use_bit_stream {
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_type = measurements_index - 1;
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_size = hash_size as u16;

        (*measurement_block)
            .measurement_block_common_header
            .measurement_size =
            (core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() + hash_size) as u16;

        if !libspdm_measurement_hash_all(
            measurement_hash_algo,
            data.as_ptr() as *mut c_void,
            data.len(),
            measurement_block.add(1) as *mut u8,
        ) {
            return 0;
        }

        core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() + hash_size
    } else {
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_type =
            (measurements_index - 1) | SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM as u8;
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_size = data.len() as u16;

        (*measurement_block)
            .measurement_block_common_header
            .measurement_size =
            core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() as u16 + data.len() as u16;

        (measurement_block.add(1) as *mut u8).copy_from(data.as_ptr(), data.len());

        core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() + data.len()
    }
}

/// # Summary
///
/// Use the already calculated `DYN_IMAGE_MEASURE` to fill the image
/// hash measurement block.
///
/// # Parameter
///
/// * `use_bit_stream`: Use raw bit-stream, no hash algorithm specified
/// * `measurement_hash_algo`: Indicates the measurement hash algorithm
/// * `measurements_index`: Index of the measurement
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
#[cfg(not(feature = "no_std"))]
unsafe fn fill_dynamic_measurement_image_hash_block(
    _use_bit_stream: bool,
    measurement_hash_algo: u32,
    measurements_index: u8,
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
) -> usize {
    let hash_size = libspdm_rs::libspdm_get_measurement_hash_size(measurement_hash_algo) as usize;

    (*measurement_block).measurement_block_common_header.index = measurements_index;

    (*measurement_block)
        .measurement_block_common_header
        .measurement_specification = libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8;

    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type = measurements_index - 1;

    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_size = hash_size as u16;

    (*measurement_block)
        .measurement_block_common_header
        .measurement_size =
        (core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() + hash_size) as u16;

    match measurements_index {
        1 => {
            let hash_offset: usize = (measurement_hash_algo.trailing_zeros()
                - SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY)
                as usize;
            let dyn_image_measure = &DYN_IMAGE_MEASURE.read().unwrap();

            if !Lazy::force(dyn_image_measure).kernel_hashes_populated {
                error!("Responder hashes not generated");
                return 0;
            }

            let hash_bytes = match Lazy::force(dyn_image_measure)
                .kernel_hashes
                .get(hash_offset)
            {
                Some(val) => val,
                None => {
                    error!("Unsupported responder hash");
                    return 0;
                }
            };

            (measurement_block.add(1) as *mut u8).copy_from(hash_bytes.as_ptr(), hash_size);

            core::mem::size_of::<spdm_measurement_block_dmtf_t>() + hash_size
        }
        2 => {
            let hash_offset = (measurement_hash_algo.trailing_zeros()
                - SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY)
                as usize;
            let dyn_image_measure = &DYN_IMAGE_MEASURE.read().unwrap();

            if !Lazy::force(dyn_image_measure).app_hashes_populated {
                error!("Responder hashes not generated");
                return 0;
            }

            let hash_bytes = match Lazy::force(dyn_image_measure).app_hashes.get(hash_offset) {
                Some(val) => val,
                None => {
                    error!("Unsupported responder hash");
                    return 0;
                }
            };

            (measurement_block.add(1) as *mut u8).copy_from(hash_bytes.as_ptr(), hash_size);

            core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() + hash_size
        }
        _ => unreachable!(),
    }
}

/// # Summary
///
/// Fill SVN measurement block.
///
/// # Parameter
///
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
unsafe fn libspdm_fill_measurement_svn_block(
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
) -> usize {
    let svn: libspdm_rs::spdm_measurements_secure_version_number_t = 0x7;

    (*measurement_block).measurement_block_common_header.index =
        LIBSPDM_MEASUREMENT_INDEX_SVN as u8;
    (*measurement_block)
        .measurement_block_common_header
        .measurement_specification = libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8;

    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_SECURE_VERSION_NUMBER as u8
            | SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM as u8;
    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_size =
        core::mem::size_of::<libspdm_rs::spdm_measurements_secure_version_number_t>() as u16;

    (*measurement_block)
        .measurement_block_common_header
        .measurement_size = core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() as u16
        + core::mem::size_of::<libspdm_rs::spdm_measurements_secure_version_number_t>() as u16;

    (measurement_block.add(1) as *mut u8).copy_from(
        &svn as *const _ as *const u8,
        core::mem::size_of::<libspdm_rs::spdm_measurements_secure_version_number_t>(),
    );

    core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
        + core::mem::size_of::<libspdm_rs::spdm_measurements_secure_version_number_t>()
}

/// # Summary
///
/// Fill manifest measurement block
///
/// # Parameter
///
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
unsafe fn libspdm_fill_measurement_manifest_block(
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
    use_bit_stream: bool,
    measurement_hash_algo: u32,
) -> usize {
    let data;
    let hash_size = libspdm_rs::libspdm_get_measurement_hash_size(measurement_hash_algo) as usize;
    // Fetch an already generated manifest.
    let size;
    #[cfg(feature = "no_std")]
    {
        data = include_bytes!("../../manifest/manifest.out.cbor");
        size = data.len();
    }
    #[cfg(not(feature = "no_std"))]
    let mut buffer = [0; LIBSPDM_MEASUREMENT_MANIFEST_SIZE as usize];
    #[cfg(not(feature = "no_std"))]
    {
        let manifest_path = Path::new("manifest/manifest.out.cbor");
        size = manifest::fetch_local_manifest(&mut buffer, manifest_path)
            .expect("failed to read manifest");
        data = buffer;
    }

    (*measurement_block).measurement_block_common_header.index =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST as u8;
    (*measurement_block)
        .measurement_block_common_header
        .measurement_specification = libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8;

    if use_bit_stream {
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_type =
            SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_MEASUREMENT_MANIFEST as u8
                | SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM as u8;
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_size = size as u16;

        (*measurement_block)
            .measurement_block_common_header
            .measurement_size =
            (core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() + size) as u16;

        (measurement_block.add(1) as *mut u8).copy_from(data.as_ptr(), size);

        core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() + size
    } else {
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_type =
            SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_MEASUREMENT_MANIFEST as u8;
        (*measurement_block)
            .measurement_block_dmtf_header
            .dmtf_spec_measurement_value_size = hash_size as u16;

        (*measurement_block)
            .measurement_block_common_header
            .measurement_size =
            (core::mem::size_of::<spdm_measurement_block_dmtf_header_t>() + hash_size) as u16;

        if !libspdm_measurement_hash_all(
            measurement_hash_algo,
            data.as_ptr() as *mut c_void,
            data.len(),
            measurement_block.add(1) as *mut u8,
        ) {
            return 0;
        }

        core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() + hash_size
    }
}

/// # Summary
///
/// Fill device mode measurement block.
///
/// # Parameter
///
/// * `measurement_block`: The measurement block structure to operate on
///
/// # Returns
///
/// The measurement block size
unsafe fn libspdm_fill_measurement_device_mode_block(
    measurement_block: *mut libspdm_rs::spdm_measurement_block_dmtf_t,
) -> usize {
    let device_mode = libspdm_rs::spdm_measurements_device_mode_t {
        operational_mode_capabilities: SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_MANUFACTURING_MODE
            | SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_VALIDATION_MODE
            | SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_NORMAL_MODE
            | SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_RECOVERY_MODE
            | SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_RMA_MODE
            | SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_DECOMMISSIONED_MODE,
        operational_mode_state: SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_NORMAL_MODE,
        device_mode_capabilities: SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_IS_ACTIVE
            | SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_IS_ACTIVE
            | SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE
            | SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE
            | SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE_AFTER_MFG,
        device_mode_state: SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_IS_ACTIVE
            | SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE_AFTER_MFG,
    };

    (*measurement_block).measurement_block_common_header.index =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_DEVICE_MODE as u8;
    (*measurement_block)
        .measurement_block_common_header
        .measurement_specification = libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF as u8;

    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type = (SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_DEVICE_MODE
        | SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM)
        as u8;
    (*measurement_block)
        .measurement_block_dmtf_header
        .dmtf_spec_measurement_value_size =
        core::mem::size_of::<libspdm_rs::spdm_measurements_device_mode_t>() as u16;

    (*measurement_block)
        .measurement_block_common_header
        .measurement_size = (core::mem::size_of::<spdm_measurement_block_dmtf_header_t>()
        + core::mem::size_of::<libspdm_rs::spdm_measurements_device_mode_t>())
        as u16;

    (measurement_block.add(1) as *mut u8).copy_from(
        &device_mode as *const _ as *const u8,
        core::mem::size_of::<libspdm_rs::spdm_measurements_device_mode_t>(),
    );

    core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
        + core::mem::size_of::<libspdm_rs::spdm_measurements_device_mode_t>()
}

/// # Summary
///
/// Used to collect/retrieve the measurements for a device.
/// The "measurement_index" parameter indicates the measurement requested.
///
/// # Parameter
///
/// * `spdm_version`: The SPDM version.
/// * `measurement_specification`: Indicates the measurement specification.
///    Must be a SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_* value in spdm.h.
///
/// * `measurement_hash_algo`: Indicates the measurement hash algorithm.
///    Must be SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_* value in spdm.h.
///
/// * `measurements_index`: The index of the measurement to collect.
/// * `request_attribute`: Request attributes.
/// * `content_changed`: Indicates if measurement response content has changed.
/// * `measurements_count`: When `measurement_index` is zero, returns the total
///                         count of measurements available for the device.
///
///     When "measurement_index" is non-zero, returns the number of measurements
///     returned in "measurements" and "measurements_size".
///     If "measurements_index" is an invalid index not supported by the device,
///     "measurements_count" returns 0.
///
/// * `measurements`: A pointer to a destination buffer to store the
///     concatenation of all device measurement blocks. This buffer will only be
///     modified if "measurement_index" is non-zero.
///
/// * `measurements_size`: On input, indicates the size in bytes of the
///                        destination buffer.
///    On output, indicates the total size in bytes of all device measurement
///     blocks in the buffer. This field should only be modified if
///     "measurement_index" is non-zero.
///
/// # Returns
///
/// Returns a libspdm returns status code as follows:
///
/// RETURN_SUCCESS:  Successfully returned measurement_count, measurements,
///                   measurements_size.
///
/// RETURN_BUFFER_TOO_SMALL: Measurements buffer too small for measurements.
/// RETURN_INVALID_PARAMETER: Invalid parameter passed to function.
/// RETURN_NOT_FOUND: Unsupported measurement index.
/// RETURN_***: Any other RETURN_ error indicating the type of failure.
#[no_mangle]
pub unsafe extern "C" fn libspdm_measurement_collection(
    _spdm_context: *mut c_void,
    spdm_version: libspdm_rs::spdm_version_number_t,
    measurement_specification: u8,
    measurement_hash_algo: u32,
    measurements_index: u8,
    request_attribute: u8,
    content_changed: *mut u8,
    measurements_count: *mut u8,
    measurements: *mut c_void,
    measurements_size: *mut usize,
) -> u32 {
    if u32::from(measurement_specification) != libspdm_rs::SPDM_MEASUREMENT_SPECIFICATION_DMTF
        || measurement_hash_algo == 0
    {
        return libspdm_status_construct!(LIBSPDM_SEVERITY_ERROR, LIBSPDM_SOURCE_CORE, 0x0002);
    }

    let hash_size = libspdm_rs::libspdm_get_measurement_hash_size(measurement_hash_algo);
    let mut measurement_ptr = measurements as *mut u8;

    let use_bit_stream = measurement_hash_algo
        == libspdm_rs::SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY
        || (u32::from(request_attribute)
            & libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_RAW_BIT_STREAM_REQUESTED)
            != 0;

    match u32::from(measurements_index) {
        SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS => {
            *measurements_count = LIBSPDM_MEASUREMENT_BLOCK_NUMBER;
        }
        SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_ALL_MEASUREMENTS => {
            /* The first HASH_NUMBER blocks may be hash values or raw bitstream*/
            for i in 1..(LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER as u8 + 1) {
                let measurement_block =
                    measurement_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;
                let measurement_block_size = libspdm_fill_measurement_image_hash_block(
                    use_bit_stream,
                    measurement_hash_algo,
                    i,
                    measurement_block,
                );
                if measurement_block_size == 0 {
                    return libspdm_status_construct!(
                        LIBSPDM_SEVERITY_ERROR,
                        LIBSPDM_SOURCE_MEAS_COLLECT,
                        0x0001
                    );
                }
                measurement_ptr = measurement_ptr.add(measurement_block_size);
            }
            /* Next one - SVN is always raw bitstream data.*/
            let measurement_block =
                measurement_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;
            let measurement_block_size = libspdm_fill_measurement_svn_block(measurement_block);
            measurement_ptr = measurement_ptr.add(measurement_block_size);

            /* Next one - manifest is always raw bitstream data.*/
            let measurement_block =
                measurement_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;
            let measurement_block_size = libspdm_fill_measurement_manifest_block(
                measurement_block,
                use_bit_stream,
                measurement_hash_algo,
            ) as u32;
            measurement_ptr = measurement_ptr.add(measurement_block_size as usize);

            /* Next one - device_mode is always raw bitstream data.*/
            let measurement_block =
                measurement_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;
            libspdm_fill_measurement_device_mode_block(measurement_block);

            /* Calculate total_size_needed based on hash algo selected.
             * If we have an hash algo, then the first HASH_NUMBER elements will be
             * hash values, otherwise HASH_NUMBER raw bitstream values.*/
            let mut total_size_needed = if !use_bit_stream {
                LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER
                    * (core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() as u32
                        + hash_size)
            } else {
                #[cfg(not(feature = "no_std"))]
                {
                    let dyn_image_measure = &DYN_IMAGE_MEASURE.read().unwrap();

                    if Lazy::get(dyn_image_measure).is_some() {
                        LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER
                            * (core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
                                as u32
                                + hash_size)
                    } else {
                        LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER
                            * (core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
                                as u32
                                + LIBSPDM_MEASUREMENT_RAW_DATA_SIZE)
                    }
                }
                #[cfg(feature = "no_std")]
                {
                    LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER
                        * (core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>() as u32
                            + LIBSPDM_MEASUREMENT_RAW_DATA_SIZE)
                }
            };
            /* Next one - SVN is always raw bitstream data.*/
            total_size_needed += core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
                as u32
                + core::mem::size_of::<libspdm_rs::spdm_measurements_secure_version_number_t>()
                    as u32;
            /* Next one - manifest is always raw bitstream data.*/
            total_size_needed += measurement_block_size;
            /* Next one - device_mode is always raw bitstream data.*/
            total_size_needed += core::mem::size_of::<libspdm_rs::spdm_measurement_block_dmtf_t>()
                as u32
                + core::mem::size_of::<libspdm_rs::spdm_measurements_device_mode_t>() as u32;

            if total_size_needed > (*measurements_size).try_into().unwrap() {
                return libspdm_status_construct!(
                    LIBSPDM_SEVERITY_ERROR,
                    LIBSPDM_SOURCE_CORE,
                    0x000d
                );
            }

            *measurements_size = total_size_needed as usize;
            *measurements_count = LIBSPDM_MEASUREMENT_BLOCK_NUMBER;
        }
        _ => {
            let measurement_block =
                measurement_ptr as *mut libspdm_rs::spdm_measurement_block_dmtf_t;
            let total_size_needed = match u32::from(measurements_index) {
                1..=LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER => {
                    libspdm_fill_measurement_image_hash_block(
                        use_bit_stream,
                        measurement_hash_algo,
                        measurements_index,
                        measurement_block,
                    )
                }
                LIBSPDM_MEASUREMENT_INDEX_SVN => {
                    libspdm_fill_measurement_svn_block(measurement_block)
                }
                SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST => {
                    libspdm_fill_measurement_manifest_block(
                        measurement_block,
                        use_bit_stream,
                        measurement_hash_algo,
                    )
                }
                SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_DEVICE_MODE => {
                    libspdm_fill_measurement_device_mode_block(measurement_block)
                }
                _ => {
                    *measurements_count = 0;
                    return libspdm_status_construct!(
                        LIBSPDM_SEVERITY_ERROR,
                        LIBSPDM_SOURCE_MEAS_COLLECT,
                        0x0000
                    );
                }
            } as u32;

            if total_size_needed == 0 {
                return libspdm_status_construct!(
                    LIBSPDM_SEVERITY_ERROR,
                    LIBSPDM_SOURCE_MEAS_COLLECT,
                    0x0001
                );
            }

            if total_size_needed > (*measurements_size).try_into().unwrap() {
                return libspdm_status_construct!(
                    LIBSPDM_SEVERITY_ERROR,
                    LIBSPDM_SOURCE_CORE,
                    0x000d
                );
            }

            *measurements_count = 1;
            *measurements_size = total_size_needed as usize;
        }
    }

    if !content_changed.is_null()
        && ((u32::from(spdm_version) >> libspdm_rs::SPDM_VERSION_NUMBER_SHIFT_BIT)
            >= libspdm_rs::SPDM_MESSAGE_VERSION_12)
    {
        /* return content change*/
        if (u32::from(request_attribute)
            & libspdm_rs::SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE)
            != 0
        {
            *content_changed =
                libspdm_rs::SPDM_MEASUREMENTS_RESPONSE_CONTENT_NO_CHANGE_DETECTED as u8;
        } else {
            *content_changed =
                libspdm_rs::SPDM_MEASUREMENTS_RESPONSE_CONTENT_CHANGE_NO_DETECTION as u8;
        }
    }

    libspdm_status_construct!(LIBSPDM_SEVERITY_SUCCESS, LIBSPDM_SOURCE_SUCCESS, 0x0000)
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        u32,
        u8,
        u8,
        *mut u8,
        *mut u8,
        *mut c_void,
        *mut usize,
    ) -> u32,
    libspdm_measurement_collection
);

/// # Summary
///
///
/// Derive HMAC-based Expand key Derivation Function (HKDF) Expand, based upon
/// the negotiated HKDF algorithm.
///
/// # Parameter
///
/// * `_spdm_version`: The SPDM version
/// * `base_hash_algo`: Indicates the hash algorithm.
/// * `psk_hint`: Pointer to the user-supplied PSK Hint.
/// * `psk_hint_size`: PSK Hint size in bytes.
/// * `info`: Pointer to the application specific info.
/// * `info_size`: `info` size in bytes.
/// * `out`: Pointer to buffer to receive hkdf value.
/// * `out_size`: Size of hkdf bytes to generate.
///
/// # Returns
///
/// True if Hkdf generated successfully, false otherwise
#[no_mangle]
pub unsafe extern "C" fn libspdm_psk_handshake_secret_hkdf_expand(
    _spdm_version: libspdm_rs::spdm_version_number_t,
    base_hash_algo: u32,
    psk_hint: *const u8,
    psk_hint_size: usize,
    info: *const u8,
    info_size: usize,
    out: *mut u8,
    out_size: usize,
) -> bool {
    if psk_hint.is_null() {
        return false;
    }

    let psk_hint = from_raw_parts(psk_hint, psk_hint_size);

    debug!("[PSK_HINT]: {:?} || SIZE {}", psk_hint, psk_hint_size);

    let mut psk;
    let psk_size: usize;

    // If no psk-hint or if the psk-hint matches what we expect
    // use the `TestPskData` data. Otherwise return an error
    if psk_hint_size == 0 || (psk_hint == PSK_HINT && psk_hint_size == PSK_LEN) {
        psk = b"TestPskData\0".clone();
        psk_size = psk.len();
    } else {
        return false;
    }

    debug!("[PSK]: {:x?}", psk);

    let mut m_libspdm_my_zero_filled_buffer: [u8; 64] = [0; 64];
    let mut handshake_secret: [u8; 64] = [0; 64];

    let buffer_ptr = m_libspdm_my_zero_filled_buffer.as_mut_ptr() as *const u8;
    let handshake_ptr = handshake_secret.as_mut_ptr();

    let hash_size = libspdm_rs::libspdm_get_hash_size(base_hash_algo) as usize;
    let ret = libspdm_rs::libspdm_hkdf_extract(
        base_hash_algo,
        psk.as_mut_ptr() as *const u8,
        psk_size,
        buffer_ptr,
        hash_size,
        handshake_ptr,
        hash_size,
    );

    if !ret {
        return ret;
    }

    let ret = libspdm_rs::libspdm_hkdf_expand(
        base_hash_algo,
        handshake_ptr,
        hash_size,
        info,
        info_size,
        out,
        out_size,
    );

    libspdm_rs::libspdm_zero_mem(&mut handshake_secret as *mut _ as *mut c_void, hash_size);

    ret
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        _spdm_version: libspdm_rs::spdm_version_number_t,
        base_hash_algo: u32,
        psk_hint: *const u8,
        psk_hint_size: usize,
        info: *const u8,
        info_size: usize,
        out: *mut u8,
        out_size: usize,
    ) -> bool,
    libspdm_psk_handshake_secret_hkdf_expand
);

/// # Summary
///
/// Derive HMAC-based Expand key Derivation Function (HKDF) Expand, based upon
/// the negotiated HKDF algorithm.
///
/// # Parameter
///
/// * `spdm_version`: The SPDM version
/// * `base_hash_algo`: Indicates the hash algorithm.
/// * `psk_hint`: Pointer to the user-supplied PSK Hint.
/// * `psk_hint_size`: PSK Hint size in bytes.
/// * `info`: Pointer to the application specific info.
/// * `info_size`: `info` size in bytes.
/// * `out`: Pointer to buffer to receive hkdf value.
/// * `out_size`: Size of hkdf bytes to generate.
///
/// # Returns
///
/// True if Hkdf generated successfully, false otherwise
#[no_mangle]
pub unsafe extern "C" fn libspdm_psk_master_secret_hkdf_expand(
    spdm_version: libspdm_rs::spdm_version_number_t,
    base_hash_algo: u32,
    psk_hint: *const u8,
    psk_hint_size: usize,
    info: *const u8,
    info_size: usize,
    out: *mut u8,
    out_size: usize,
) -> bool {
    if psk_hint.is_null() {
        return false;
    }

    let psk_hint = from_raw_parts(psk_hint, psk_hint_size);

    debug!("[PSK_HINT]: {:?}", psk_hint);

    let mut psk;
    let psk_size: usize;

    // If no psk-hint or if the psk-hint matches what we expect
    // use the `TestPskData` data. Otherwise return an error
    if psk_hint_size == 0 || (psk_hint == PSK_HINT && psk_hint_size == PSK_LEN) {
        psk = b"TestPskData\0".clone();
        psk_size = psk.len();
    } else {
        return false;
    }

    debug!("[PSK]: {:x?}", psk);

    let mut m_libspdm_my_zero_filled_buffer: [u8; 64] = [0; 64];
    let mut handshake_secret: [u8; 64] = [0; 64];

    let buffer_ptr = m_libspdm_my_zero_filled_buffer.as_mut_ptr() as *const u8;
    let handshake_ptr = handshake_secret.as_mut_ptr();

    let hash_size = libspdm_rs::libspdm_get_hash_size(base_hash_algo) as usize;
    let ret = libspdm_rs::libspdm_hkdf_extract(
        base_hash_algo,
        psk.as_mut_ptr() as *const u8,
        psk_size,
        buffer_ptr,
        hash_size,
        handshake_ptr,
        hash_size,
    );

    if !ret {
        return ret;
    }

    let hash_size_u16 = u16::try_from(hash_size).unwrap();
    let m_libspdm_bin_str0_len = core::mem::size_of::<u16>()
        + SPDM_VERSION_1_1_BIN_CONCAT_LABEL.len()
        + SPDM_BIN_STR_0_LABEL.len();
    let mut m_libspdm_bin_str0: Vec<u8> = Vec::with_capacity(m_libspdm_bin_str0_len);

    m_libspdm_bin_str0.extend_from_slice(&hash_size_u16.to_le_bytes());
    m_libspdm_bin_str0.extend_from_slice(SPDM_VERSION_1_1_BIN_CONCAT_LABEL);
    m_libspdm_bin_str0[6] = b'0' + ((spdm_version >> 12) & 0xF) as u8;
    m_libspdm_bin_str0[8] = b'0' + ((spdm_version >> 8) & 0xF) as u8;
    m_libspdm_bin_str0.extend_from_slice(SPDM_BIN_STR_0_LABEL);

    let mut salt1: [u8; 64] = [0; 64];

    let ret = libspdm_rs::libspdm_hkdf_expand(
        base_hash_algo,
        handshake_ptr,
        hash_size,
        m_libspdm_bin_str0.as_ptr() as *const u8,
        m_libspdm_bin_str0_len,
        salt1.as_mut_ptr(),
        hash_size,
    );

    libspdm_rs::libspdm_zero_mem(handshake_secret.as_mut_ptr() as *mut c_void, hash_size);

    if !ret {
        return ret;
    }

    let mut master_secret: [u8; 64] = [0; 64];

    let ret = libspdm_rs::libspdm_hkdf_extract(
        base_hash_algo,
        buffer_ptr,
        hash_size,
        salt1.as_mut_ptr(),
        hash_size,
        master_secret.as_mut_ptr(),
        hash_size,
    );

    libspdm_rs::libspdm_zero_mem(salt1.as_mut_ptr() as *mut c_void, hash_size);

    if !ret {
        return ret;
    }

    let ret = libspdm_rs::libspdm_hkdf_expand(
        base_hash_algo,
        master_secret.as_mut_ptr(),
        hash_size,
        info,
        info_size,
        out,
        out_size,
    );

    libspdm_rs::libspdm_zero_mem(master_secret.as_mut_ptr() as *mut c_void, hash_size);
    ret
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        spdm_version: libspdm_rs::spdm_version_number_t,
        base_hash_algo: u32,
        psk_hint: *const u8,
        psk_hint_size: usize,
        info: *const u8,
        info_size: usize,
        out: *mut u8,
        out_size: usize,
    ) -> bool,
    libspdm_psk_master_secret_hkdf_expand
);

/// # Summary
///
/// Format the certificate specified by `path` into what `libspdm` expects
#[no_mangle]
pub unsafe extern "C" fn libspdm_measurement_opaque_data(
    _spdm_context: *mut c_void,
    _spdm_version: libspdm_rs::spdm_version_number_t,
    _measurement_specification: u8,
    _measurement_hash_algo: u32,
    _measurement_index: u8,
    _request_attribute: u8,
    opaque_data: *mut c_void,
    opaque_data_size: *mut usize,
) -> bool {
    let opaque_len = OPAQUE_SIZE.min(*opaque_data_size);
    let opaque_buf = opaque_data as *mut u8;
    let opaque = unsafe { from_raw_parts_mut(opaque_buf, opaque_len) };

    *opaque_data_size = opaque_len;

    for (i, b) in opaque.iter_mut().enumerate() {
        *b = i as u8;
    }

    true
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        u32,
        u8,
        u8,
        *mut c_void,
        *mut usize,
    ) -> bool,
    libspdm_measurement_opaque_data
);

#[no_mangle]
pub unsafe extern "C" fn libspdm_challenge_opaque_data(
    _spdm_context: *mut c_void,
    _spdm_version: libspdm_rs::spdm_version_number_t,
    _slot_id: u8,
    _measurement_summary_hash: *mut u8,
    _measurement_summary_hash_size: usize,
    opaque_data: *mut c_void,
    opaque_data_size: *mut usize,
) -> bool {
    let opaque_len = OPAQUE_SIZE.min(*opaque_data_size);
    let opaque_buf = opaque_data as *mut u8;
    let opaque = unsafe { from_raw_parts_mut(opaque_buf, opaque_len) };

    *opaque_data_size = opaque_len;

    for (i, b) in opaque.iter_mut().enumerate() {
        *b = i as u8;
    }

    true
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        *mut u8,
        usize,
        *mut c_void,
        *mut usize,
    ) -> bool,
    libspdm_challenge_opaque_data
);

#[no_mangle]
pub unsafe extern "C" fn libspdm_encap_challenge_opaque_data(
    _spdm_context: *mut c_void,
    _spdm_version: libspdm_rs::spdm_version_number_t,
    _slot_id: u8,
    _measurement_summary_hash: *mut u8,
    _measurement_summary_hash_size: usize,
    opaque_data: *mut c_void,
    opaque_data_size: *mut usize,
) -> bool {
    let opaque_len = OPAQUE_SIZE.min(*opaque_data_size);
    let opaque_buf = opaque_data as *mut u8;
    let opaque = unsafe { from_raw_parts_mut(opaque_buf, opaque_len) };

    *opaque_data_size = opaque_len;

    for (i, b) in opaque.iter_mut().enumerate() {
        *b = i as u8;
    }

    true
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        libspdm_rs::spdm_version_number_t,
        u8,
        *mut u8,
        usize,
        *mut c_void,
        *mut usize,
    ) -> bool,
    libspdm_encap_challenge_opaque_data
);

/// # Summary
///
/// NOTE: This function currently wraps around `libspdm_gen_csr()` to implement
///       GET_CSR support for libspmd for SPDM versions >= 1.3. We only offer
///       limited support in that:
///            i. The responder NEVER returns a CsrTrackingTag, Csr generation
///                 in immediate (no reset needed).
///           ii. Requester must not request a CsrTrackingTag [1, 7], only 0
///                 allowed.
///
/// If an spdm-utils responder and requester is used, this should not
/// be problematic.
///
/// Saves a certificate pointed to by `cert_chain` to device non-volatile memory
/// into the respective `slot_id`. Once saved, import the file and use it as
///  the certificate
///
/// # Parameter
///
/// * `base_hash_algo`: Indicates the hash algo for signing
/// * `base_asym_algo`: The asymmetric public key to set
/// * `need_reset`: The device needs reset to generate a CSR
/// * `requester_info`: Requester information to generate a CSR
/// * `requester_info_length`: The length of `requester_info`
/// * `csr_len`: For input, csr_len is the size of store CSR buffer.
///              For output, csr_len is CSR len for DER format
///
/// * `csr_pointer`: For input, csr_pointer is buffer address to store CSR.
///                  For output, csr_pointer is address for stored CSR.
///                  The csr_pointer address will be changed.
///
/// * `req_cert_model`:   libspdm Certificate model
/// * `csr_tracking_tag`: Responder provided CsrTrackingTag (>=SPDM1.3)
/// * `overwrite`:        If set, the Responder shall stop processing any existing GET_CSR
///                       request and overwrite it with this request.
/// # Returns
///
/// True if CSR generation was a success, false otherwise
#[no_mangle]
pub unsafe extern "C" fn libspdm_gen_csr_ex(
    spdm_context: *mut c_void,
    base_hash_algo: c_uint,
    base_asym_algo: c_uint,
    need_reset: *mut bool,
    request: *const c_void,
    request_size: usize,
    requester_info: *mut c_uchar,
    requester_info_length: usize,
    opaque_data: *mut c_uchar,
    opaque_data_length: u16,
    csr_len: *mut usize,
    csr_pointer: *mut c_uchar,
    req_cert_model: c_uchar,
    csr_tracking_tag: *mut c_uchar,
    _req_key_pair_id: u8,
    overwrite: bool,
) -> bool {
    // TODO: The CSR generation supported by spdm-utils based responder does not currently
    //       support CSR caching, i.e in a situation where the responder needs a resetto process a
    //       GET_CSCSR request.
    //
    //       so an spdm-utils requester should never request to see a cached
    //       CSR using a csr_tracking_tag value of [1, 7].
    assert!(*csr_tracking_tag == 0);
    // TODO: Overwrite is not supported
    assert!(!overwrite);
    let is_device_cert_model = {
        if req_cert_model == 1 {
            true
        } else {
            false
        }
    };
    return libspdm_gen_csr(
        spdm_context,
        base_hash_algo,
        base_asym_algo,
        need_reset,
        request,
        request_size,
        requester_info,
        requester_info_length,
        opaque_data,
        opaque_data_length,
        csr_len,
        csr_pointer,
        is_device_cert_model,
    );
}

#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(
        *mut c_void,
        c_uint,
        c_uint,
        *mut bool,
        *const c_void,
        usize,
        *mut c_uchar,
        usize,
        *mut c_uchar,
        u16,
        *mut usize,
        *mut c_uchar,
        c_uchar,
        *mut c_uchar,
        u8,
        bool,
    ) -> bool,
    libspdm_gen_csr_ex
);

/// for the LIBSPDM_DATA_BASE_HASH_ALGO data.
///
/// # Parameter
///
/// * `path`: Path to certificate
/// * `asym_algo`: Indicates the asymmetric algorithm.
/// * `hash_algo`: Indicates the hashing algorithm.
///
/// # Returns
///
/// Returns a tuple with a buffer containing the certificate chain and it's size
///
/// # Panics
///
/// Panics if `path` is invalid or if a file I/O error occurs.
/// Panics if the cert chain failed to verify in `libspdm`
pub unsafe fn get_local_certchain(
    buffer: &[u8],
    _asym_algo: u32,
    hash_algo: u32,
    _is_requester_cert: bool,
) -> (*mut c_void, usize) {
    let mut root_cert_buffer: *const u8 = ptr::null_mut();
    let mut root_cert_size = 0;

    let buffer_len = buffer.len();

    if !libspdm_rs::libspdm_x509_get_cert_from_cert_chain(
        buffer.as_ptr(),
        buffer_len,
        0,
        &mut root_cert_buffer,
        &mut root_cert_size,
    ) {
        panic!("Unable to get cert from x509");
    }

    let digest_size = libspdm_rs::libspdm_get_hash_size(hash_algo) as usize;

    let cert_chain_size =
        core::mem::size_of::<libspdm_rs::spdm_cert_chain_t>() + digest_size + buffer_len;
    let cert_chain_layout = Layout::from_size_align(cert_chain_size, 8).unwrap();
    let cert_chain_buffer = alloc(cert_chain_layout);

    assert!(cert_chain_buffer != ptr::null_mut());

    let cert_chain = cert_chain_buffer as *mut libspdm_rs::spdm_cert_chain_t;

    (*cert_chain).length = cert_chain_size as u16;
    (*cert_chain).reserved = 0;

    if !libspdm_rs::libspdm_hash_all(
        hash_algo,
        root_cert_buffer as *const _ as *const c_void,
        root_cert_size,
        cert_chain_buffer.add(core::mem::size_of::<libspdm_rs::spdm_cert_chain_t>()),
    ) {
        panic!("Unable to hash data");
    }

    let cert_buffer_location =
        cert_chain_buffer.add(core::mem::size_of::<libspdm_rs::spdm_cert_chain_t>() + digest_size);
    cert_buffer_location.copy_from(buffer.as_ptr(), buffer_len);

    (cert_chain_buffer as *mut c_void, cert_chain_size)
}

/// # Summary
///
/// Gets the base asym algorithm
///
/// # Parameter
///
/// * `cntx_ptr`: The SPDM context
/// * `slot_id`: Session slot id
///
/// # Returns
///
/// Returns Ok(SpdmAlgoBaseHash) on success or a libspdm error code on error
pub unsafe fn get_base_asym_algo(
    cntx_ptr: *mut c_void,
    slot_id: u8,
) -> Result<SpdmAlgoBaseAsym, u32> {
    let parameter = libspdm_rs::libspdm_data_parameter_t::new_connection(slot_id);
    let mut spdm_algo_asym_hash = SpdmAlgoBaseAsym(0);
    let hash_dptr = &mut spdm_algo_asym_hash.0 as *mut _ as *mut c_void;
    let mut data_size: usize = core::mem::size_of::<u32>();

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_BASE_HASH_ALGO,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        hash_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    Ok(spdm_algo_asym_hash)
}

/// # Summary
///
/// Gets the base hash algorithm
///
/// # Parameter
///
/// * `cntx_ptr`: The SPDM context
/// * `slot_id`: Session slot id
///
/// # Returns
///
/// Returns Ok(SpdmAlgoBaseHash) on success or a libspdm error code on error
pub unsafe fn get_base_hash_algo(
    cntx_ptr: *mut c_void,
    slot_id: u8,
) -> Result<SpdmAlgoBaseHash, u32> {
    let parameter = libspdm_rs::libspdm_data_parameter_t::new_connection(slot_id);
    let mut spdm_algo_base_hash = SpdmAlgoBaseHash(0);
    let hash_dptr = &mut spdm_algo_base_hash.0 as *mut _ as *mut c_void;
    let mut data_size: usize = core::mem::size_of::<u32>();

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_BASE_HASH_ALGO,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        hash_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    Ok(spdm_algo_base_hash)
}

/// # Summary
///
/// Gets the algorithms negotiated in this context and prints them
///
/// # Parameter
///
/// * `cntx_ptr`: The SPDM context
/// * `slot_id`: Session slot id
///
/// # Returns
///
/// Returns Ok(()) on success or a libspdm error code
pub unsafe fn get_negotiated_algos(cntx_ptr: *mut c_void, slot_id: u8) -> Result<(), u32> {
    debug!("The following algorithms were negotiated with the endpoint:");
    let parameter = libspdm_rs::libspdm_data_parameter_t::new_connection(slot_id);

    let mut spdm_algo_base_asym = SpdmAlgoBaseAsym(0);
    let asym_dptr = &mut spdm_algo_base_asym.0 as *mut _ as *mut c_void;

    let mut spdm_algo_base_hash = SpdmAlgoBaseHash(0);
    let hash_dptr = &mut spdm_algo_base_hash.0 as *mut _ as *mut c_void;

    let mut spdm_dhe = SpdmAlgoDheNamedGroup(0);
    let dhe_dptr = &mut spdm_dhe.0 as *mut _ as *mut c_void;

    let mut spdm_aead_cipher = SpdmAlgoAeadCipherSuite(0);
    let aead_dptr = &mut spdm_aead_cipher.0 as *mut _ as *mut c_void;

    let mut spdm_key_sched = SpdmAlgoKeyScheduleHmacHash(0);
    let key_sched_dptr = &mut spdm_key_sched.0 as *mut _ as *mut c_void;

    let mut data_size: usize = core::mem::size_of::<u32>();

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_BASE_ASYM_ALGO,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        asym_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }
    debug!("{}", spdm_algo_base_asym);
    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_BASE_HASH_ALGO,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        hash_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }
    debug!("{}", spdm_algo_base_hash);

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_DHE_NAME_GROUP,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        dhe_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }
    debug!("{}", spdm_dhe);

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_AEAD_CIPHER_SUITE,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        aead_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }
    debug!("{}", spdm_aead_cipher);

    let ret = libspdm_rs::libspdm_get_data(
        cntx_ptr,
        libspdm_rs::libspdm_data_type_t_LIBSPDM_DATA_KEY_SCHEDULE,
        &parameter as *const libspdm_rs::libspdm_data_parameter_t,
        key_sched_dptr,
        &mut data_size,
    );

    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }
    debug!("{}", spdm_key_sched);

    Ok(())
}

/// return if current code is running in a trusted environment.
#[no_mangle]
pub unsafe extern "C" fn libspdm_is_in_trusted_environment(_spdm_context: *mut c_void) -> bool {
    true
}
#[cfg(test)]
libspdm_match_fn_prototypes!(
    unsafe extern "C" fn(*mut c_void) -> bool,
    libspdm_is_in_trusted_environment
);

pub unsafe fn requester_respond_if_ready(
    cntx_ptr: *mut c_void,
    session_info: &mut SpdmSessionInfo,
    expected_response_code: u8,
) -> Result<(), u32> {
    let context = cntx_ptr as *mut libspdm_rs::libspdm_context_t;
    let session_id_ptr = &mut session_info.session_id as *mut u32;
    let mut msg_size: usize = 0;
    let mut msg: u8 = 0x00;
    let msg_ptr_ptr = &mut (&mut msg as *mut _) as *mut *mut _ as *mut *mut c_void;

    let ret = libspdm_rs::libspdm_acquire_sender_buffer(
        cntx_ptr as *mut libspdm_rs::libspdm_context_t,
        &mut msg_size as *mut _ as *mut usize,
        msg_ptr_ptr,
    );
    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    let transport_header_size: usize =
        (*context).local_context.capability.transport_header_size as usize;

    assert!(
        msg_size
            >= (transport_header_size
                + (*context).local_context.capability.transport_tail_size as usize)
    );

    let spdm_version: u8 = libspdm_rs::libspdm_get_connection_version(context);

    let spdm_req = (*msg_ptr_ptr).add(transport_header_size);
    let spdm_req_ptr = spdm_req as *mut libspdm_rs::spdm_response_if_ready_request_t;
    (*spdm_req_ptr).header.spdm_version = spdm_version;
    (*spdm_req_ptr).header.request_response_code =
        u8::try_from(libspdm_rs::SPDM_RESPOND_IF_READY).unwrap();
    // Since there wasn't an error (NOT_READY), this will
    // default to zero. Spec states that this should be "The original
    // request code that triggered the ResponseNotReady error code
    // response"
    (*spdm_req_ptr).header.param1 = (*context).error_data.request_code;
    (*spdm_req_ptr).header.param2 = (*context).error_data.token;

    let spdm_request_size = core::mem::size_of::<libspdm_rs::spdm_response_if_ready_request_t>();

    let ret = libspdm_rs::libspdm_send_spdm_request(
        cntx_ptr as *mut libspdm_rs::libspdm_context_t,
        session_id_ptr,
        spdm_request_size,
        spdm_req_ptr as *mut _ as *mut c_void,
    );
    libspdm_rs::libspdm_release_sender_buffer(cntx_ptr as *mut libspdm_rs::libspdm_context_t);
    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    let mut response_size: usize = 0;
    let mut response: u8 = 0x00;
    let response_ptr_ptr = &mut (&mut response as *mut _) as *mut *mut _ as *mut *mut c_void;

    let ret = libspdm_rs::libspdm_acquire_receiver_buffer(
        cntx_ptr as *mut libspdm_rs::libspdm_context_t,
        &mut response_size as *mut _ as *mut usize,
        response_ptr_ptr,
    );
    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    assert!(response_size >= transport_header_size);

    libspdm_rs::libspdm_zero_mem(*response_ptr_ptr, response_size);

    let ret = libspdm_rs::libspdm_receive_spdm_response(
        cntx_ptr as *mut libspdm_rs::libspdm_context_t,
        session_id_ptr,
        &mut response_size as *mut usize,
        response_ptr_ptr,
    );
    if LibspdmReturnStatus::libspdm_status_is_error(ret) {
        return Err(ret);
    }

    let spdm_response = (*response_ptr_ptr) as *mut libspdm_rs::spdm_message_header_t;

    if response_size < core::mem::size_of::<libspdm_rs::spdm_message_header_t>() {
        return Err(LIBSPDM_STATUS_INVALID_MSG_SIZE);
    }

    if (*spdm_response).spdm_version != spdm_version {
        return Err(LIBSPDM_STATUS_INVALID_MSG_FIELD);
    }

    if u32::try_from((*spdm_response).request_response_code).unwrap() == libspdm_rs::SPDM_ERROR {
        // TODO: This request will typically fail here, as
        // SPDM-Utils responder is not expecting a RespondIfReady.
        let ret =
            libspdm_rs::libspdm_handle_simple_error_response(context, (*spdm_response).param1);
        return Err(ret);
    }

    if (*spdm_response).request_response_code != expected_response_code {
        return Err(LIBSPDM_STATUS_INVALID_MSG_FIELD);
    }

    Ok(())
}
